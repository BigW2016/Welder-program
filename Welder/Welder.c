/*
 * Welder.c
 *
 * Created: 29.11.2017 16:53:22
 *  Author: Wraith
 */ 

//макросы для автоматического определения параметров
#define __GET_DDR(DDR_LETTER) DDR ## DDR_LETTER
#define GET_DDR(DDR_LETTER) __GET_DDR(DDR_LETTER)

#define __GET_PORT(PORT_LETTER) PORT ## PORT_LETTER
#define GET_PORT(PORT_LETTER) __GET_PORT(PORT_LETTER)

#define __GET_PORT_DATA(PORT_LETTER, PORT_PIN) (((PIN ## PORT_LETTER)&(1<<(P ## PORT_LETTER ## PORT_PIN)))>>(P ## PORT_LETTER ## PORT_PIN))
#define GET_PORT_DATA(PORT_LETTER, PORT_PIN) __GET_PORT_DATA(PORT_LETTER, PORT_PIN)


#define __GET_PORT_DATA(PORT_LETTER, PORT_PIN) (((PIN ## PORT_LETTER)&(1<<(P ## PORT_LETTER ## PORT_PIN)))>>(P ## PORT_LETTER ## PORT_PIN))
#define GET_PORT_DATA(PORT_LETTER, PORT_PIN) __GET_PORT_DATA(PORT_LETTER, PORT_PIN)

#define TriacON PTRIAC |=(1<<PINTRIAC)
#define TriacOFF PTRIAC &=~(1<<PINTRIAC)



#define F_CPU 8000000UL
#define NO_DELAY 1


#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "Encoder.h"
#include "7Segment.h"

//управление симистором
#define DTRIAC DDRC
#define PTRIAC PORTC
#define PINTRIAC 4


//управление транзистором, отвечающим за младший индикатор
#define DSEG0 DDRB
#define PSEG0 PORTB
#define PINSEG0 0


//управление транзистором, отвечающим за старший индикатор
#define DSEG1 DDRD
#define PSEG1 PORTD
#define PINSEG1 7


volatile uint8_t	EncoderFlag = 0;//флаг прерывания энкодера
volatile uint16_t	EncCounter = 0;
volatile uint8_t	EncCurState=0;//содержится состояние энкодера, нужно хранить для определения направления вращения
volatile uint8_t	EncPushDown=0;//для работы с кнопкой


volatile uint8_t	SSegmentFlag = 0;//флаг прерывания таймера
volatile uint16_t	SSegmentText = 0;//для хранения цифр на индикаторе (старший и младший разряды)
volatile uint8_t	SSegmentDigit = 1;//разряд индикатора (всего 2) нужно для отображения обооих цифр одновременно


volatile uint8_t	ButtonFlag = 0;//флаг прерывания кнопки
volatile uint8_t	WelderCount=0;//для подсчета периодов


void InitInt1 (void)
{
	//инициализация прерывания кнопки
	//по обоим фронтам-для ручной сварки по кнопке
	EICRA &=0;
	EICRA=(0<<ISC11)|(1<<ISC10);
	EIMSK|=(1<<INT1);
}


ISR(INT0_vect)
{
	//прерывание INT0 - переход фазы через 0
	//уменьшаем счетчик периодов на 1 ~20мс (220В 50Гц)
	WelderCount--;
	
	if (WelderCount>128)
	{
		//ушел в минус
		WelderCount=0;
		//запрещаем прерывание фазы
		EIMSK&=~(1<<INT0);
		//отключаем симистор
		TriacOFF;
		//восстанавливаем прерывание кнопки, т.к. иначе не зайдет по флагу в основном цикле
		InitInt1();

	}

}

ISR(INT1_vect)
{
	//восстанавливаем флаг прерывания если вдруг произойдет INT0
	sei();
	//прерывание INT1 - Нажата кнопка
	ButtonFlag = 1;
}


ISR(PCINT1_vect)
{
	//восстанавливаем флаг прерыванияесли вдруг произойдет INT0
	sei();
	EncoderFlag = 1;
	EncCurState <<= 2;
	EncCurState &= 0b00001100;
	EncCurState |= ((GET_ENCODER_PORT_DATA(ENCPOLL_A_PORT, ENCPOLL_A_PIN)<<1)|(GET_ENCODER_PORT_DATA(ENCPOLL_B_PORT, ENCPOLL_B_PIN)));
	
}


ISR(TIMER0_COMPA_vect)
{
	//восстанавливаем флаг прерыванияесли вдруг произойдет INT0
	sei();
	//прерывание таймера 0
	//20мс прошло
	//сбрасываем значение счетчика энкодера
	TCNT0 = 0;
	//выставляем флаг обновления экрана
	SSegmentFlag = 1;
}



void InitTimer2 (void)
{
	//На частоте тактов 8 МГц
	//предделитель на 1024: 1 тик - 0,000128 сек, для 20мс нужно ~156 тиков
	
	TCCR0B=0;
	TCCR0B |= (1<<COM0B0);
	OCR0B = 90;
	
	TCCR0B |= (1<<CS02)|(0<<CS01)|(1<<CS00);
	//разрешаем прерыванеи по совпадению
	TIMSK0 |= (1<<OCIE0B);
	TCNT2 = 0;
}

void InitInt0 (void)
{
	//инициализация прерывания при переходе фазы через 0
	//по спадающему фронту
	EICRA &=0;
	EICRA=(1<<ISC01)|(0<<ISC00);
	EIMSK|=(1<<INT0);
}

void InitPCICR (void)
{
	//инициализация прерываний энкодера
	PCMSK1&=0;
	PCICR&=0;
	//включаем прерывание на PCINT[14:8]
	PCICR|=(1<<PCIE1);
	//разрешаем прерывание PCINT8,9,10
	PCMSK1|=(1<<PCINT8)|(1<<PCINT9)|(1<<PCINT10);
}


int8_t	EncPollDelta()
{
	
	return pgm_read_byte(&(EncState[EncCurState]));
}

/*
static uint8_t TurnBitsAround( uint8_t aByte )//инвертируем биты в байте и меням соседние биты местами 
												//- из-за разводки
{
return (aByte & 0x80 ? 0x02 : 0) |
(aByte & 0x40 ? 0x01 : 0) |
(aByte & 0x20 ? 0x08 : 0) |
(aByte & 0x10 ? 0x04 : 0) |
(aByte & 0x08 ? 0x20 : 0) |
(aByte & 0x04 ? 0x10 : 0) |
(aByte & 0x02 ? 0x80 : 0) |
(aByte & 0x01 ? 0x40 : 0);
}*/


void TriacInit(void)
{
	DTRIAC |= (1<<PINTRIAC);
	PTRIAC &=~(1<<PINTRIAC);
}


/*
void TriacON(void)
{
	PTRIAC |=(1<<PINTRIAC);
}
*/

/*
void TriacOFF(void)
{
	PTRIAC &=~(1<<PINTRIAC);
}*/


void SsegmentShow(void)
{
	//обнуляем старшие биты (т.к. они должны быть = 0)
	SSegmentDigit &= 3;
	//инвертируем разряд
	SSegmentDigit ^= 1;
			
	if (!(EncPushDown))
	{
		SSegmentText = (EncCounter/10) << 8;
		SSegmentText = (EncCounter%10);
		SSegmentOut(SSegmentText>>(8*SSegmentDigit));
	}
			
	if (SSegmentDigit)
	{
		PSEG0 &= ~(0<<PINSEG0);
		PSEG1 |= (1<<PINSEG0);
	}
	else
	{
		PSEG0 |= (1<<PINSEG0);
		PSEG1 &= ~(0<<PINSEG0);
	}

}


int main(void)
{
	cli();
	int8_t EncStep =0; //счетчик кол-ва шагов для изменения цифры на индикаторе
	
	//общая инициализация портов - вход с подтяжкой
	DDRB=0;
	PORTB=0xFF;
	DDRC=0;
	PORTC=0xFF;
	DDRD=0;
	PORTD=0xFF;

	//настраиваем пины катодов сегментов
	//на выход и выставляем 0
	DSEG0 |= (1<<PINSEG0);
	PSEG0 &= ~(0<<PINSEG0);
	DSEG1 |= (1<<PINSEG1);
	PSEG1 &= ~(0<<PINSEG1);
	
	InitInt1();//нажатие кнопки
	InitPCICR();//прерывания от энкодера (PCINT8, PCINT9) и его кнопки PCINT10
	InitTimer2();//для индикации
	
	//проверяем индикаторы
	SSegmentOn();
	PSEG0 &= ~(0<<PINSEG0);
	PSEG1 |= (1<<PINSEG0);
	_delay_ms(150);
	PSEG0 |= (1<<PINSEG0);
	PSEG1 &= ~(0<<PINSEG0);
	_delay_ms(150);
	SSegmentOFF();
	
	
	EncoderFlag=0;
	ButtonFlag=0;
	
	//инициализация остальных ножек
	
	TriacInit(); //инициализация порат симистора
	
	
	
	//разрешаем прерывания
	sei();

    while(1)
    {

		//обновляем индикатор
		if (SSegmentFlag) 
		{
			SSegmentFlag = 0;
			SsegmentShow();
		}

		//нажата кнопка
		if (ButtonFlag)
		{
			ButtonFlag = 0;
			_delay_ms(20);
			if (GET_PORT_DATA(D,3) == 0)
			//все еще нажата - не дребезг
			{
				if (!(EncPushDown))
				{
					//если мы в режиме счета периодов
					//запрещаем прерывание кнопки
					EIMSK&=~(1<<INT1);
					//запрещаем прерывание энкодера
					PCICR&=~(1<<PCIE1);
					//заносим количество периодов для сварки
					WelderCount = EncCounter;
					//включаем симистор
					TriacON;
					//запускаем отсчет периодов
					InitInt0();
					
				}
				else
				{
					//если мы на ручном управлении - надо включить симистор и ждать пока отпустят кнопку	
					TriacON;
				}
			}
			else
			{
				//кнопку отпустили или дребезг, но не важно
				
				//если мы на ручном управлении
				if (EncPushDown)
				{
					//отключаем симистор
					TriacOFF;
					
				}
				else
				{
					//если в режиме счета периодов
					if (WelderCount == 0)
					{
						//отключаем триак, но он уже отключен из прерывания
						TriacOFF;
						//периоды истекли
						//восстанавливаем прерывание энкодера (не будет работаь еслил после окончания сварки держать кнопку - незачем)
						InitPCICR();
						
					}		
				}

			}
		}
		
		
		
		
		
		
		
		
		
		
		
		//было прерывание энкодера
		if (EncoderFlag) {
			//снимаем флаг
			EncoderFlag=0;
			_delay_ms(20);
			//определяем нажата ли кнопка энкодера
			if (GET_PORT_DATA(C,3) == 0) 
			{
				//инвертируем флаг отображения цифр
				EncPushDown ^= 1;

				if (EncPushDown)
				{
					//нажата - переходим в режим ручной выдержки
					//выставляем на индикаторе "--"
					SSegmentOut(10);
				}
				//поднимаем флаг обновления индикатора
				SSegmentFlag=1;
			
			}
			else
			{
				//не нажата
				//определяем положение энкодера
				EncStep += EncPollDelta(EncCurState);
				if (EncStep>0) {
					EncStep=0;	
					EncCounter++;
				}
				if (EncStep<0) {
					EncStep=0;
					EncCounter--;
				}
			
				//т.к. byte то если меньше 0 становится 255
				if (EncCounter > 128) EncCounter = 0;
				if (EncCounter > 99) EncCounter = 99;
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			}
		}
    }
}